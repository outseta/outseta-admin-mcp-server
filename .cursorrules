# Outseta Admin MCP Server - Adding New Tools

This document explains how to add new tools to the Outseta Admin MCP Server based on the existing patterns.

## Project Structure

The project follows a modular structure where each domain has its own directory:

```
src/
├── api/           # Core API configuration and shared schemas
├── crm_accounts/  # CRM accounts tools
├── billing_plans/ # Billing plans tools
├── billing_subscriptions/ # Subscription management tools
├── index.ts       # Server entry point
└── tools.ts       # Tool registration
```

## Adding a New Tool Category

### Step 1: Create Domain Directory

Create a new directory under `src/` for your domain (e.g., `src/crm_people/`):

```bash
mkdir src/your_domain/
```

### Step 2: Create Schema File

Create `src/your_domain/schema.ts` to define Zod schemas for your tool parameters:

```typescript
import { z } from "zod";

// Example schema for creating a new resource
export const createResourceSchema = z.object({
  name: z.string().describe("The name of the resource"),
  isActive: z.boolean().describe("Whether the resource is active"),
  // Add other fields as needed
});

// Example schema for updating a resource
export const updateResourceSchema = z.object({
  uid: z.string().describe("The unique identifier of the resource"),
  name: z.string().optional().describe("The name of the resource"),
  // Add other fields as needed
});
```

### Step 3: Create Implementation File

Create `src/your_domain/index.ts` with your API implementations:

```typescript
import { z } from "zod";
import outseta, { PaginatedResults, QueryParams } from "../api/index.js";
import { createResourceSchema, updateResourceSchema } from "./schema.js";

// Export schemas and types
export { createResourceSchema, updateResourceSchema };
export type CreateResourceParams = z.infer<typeof createResourceSchema>;
export type UpdateResourceParams = z.infer<typeof updateResourceSchema>;

// GET operation (list resources with pagination)
export const getResources = async (params: QueryParams) => {
  return await outseta.get<PaginatedResults<any>>("/your/endpoint", {
    params,
  });
};

// POST operation (create resource)
export const createResource = async (params: CreateResourceParams) => {
  // Transform params to match Outseta API format (PascalCase)
  const outsetaParams = {
    Name: params.name,
    IsActive: params.isActive,
    // Transform other fields as needed
  };
  return await outseta.post("/your/endpoint", outsetaParams);
};

// PUT operation (update resource)
export const updateResource = async (params: UpdateResourceParams) => {
  const { uid, ...updateData } = params;

  // Transform params to match Outseta API format
  const outsetaParams = {
    Name: updateData.name,
    // Transform other fields as needed
  };

  return await outseta.put(`/your/endpoint/${uid}`, outsetaParams);
};
```

### Step 4: Register Tools

Add your tools to `src/tools.ts`:

```typescript
import * as yourDomain from "./your_domain/index.js";

export const registerTools = (server: McpServer) => {
  // ... existing tools ...

  // GET tool (with pagination and filtering)
  server.tool(
    "get_resources",
    `Get resources from Outseta. ${PAGINATION_DESCRIPTION} ${FILTERING_DESCRIPTION}`,
    queryParamsSchema.shape,
    async (params: QueryParams) => {
      return toolResponse(yourDomain.getResources, params, "get_resources");
    }
  );

  // CREATE tool (requires confirmation)
  server.tool(
    "create_resource",
    `Create a resource in Outseta. ${CONFIRMATION_DESCRIPTION}`,
    yourDomain.createResourceSchema.shape,
    async (params: yourDomain.CreateResourceParams) => {
      return toolResponse(yourDomain.createResource, params, "create_resource");
    }
  );

  // UPDATE tool (requires confirmation)
  server.tool(
    "update_resource",
    `Update a resource in Outseta. ${CONFIRMATION_DESCRIPTION}`,
    yourDomain.updateResourceSchema.shape,
    async (params: yourDomain.UpdateResourceParams) => {
      return toolResponse(yourDomain.updateResource, params, "update_resource");
    }
  );
};
```

## Tool Patterns

### 1. GET Tools (List)

- Use `QueryParams` type for pagination and filtering
- Use `queryParamsSchema.shape` for the tool schema
- Include `PAGINATION_DESCRIPTION` and `FILTERING_DESCRIPTION` in tool description
- API endpoint returns `PaginatedResults<T>`

### 2. CREATE Tools (Create, Update, Delete)

- Define custom Zod schema with required fields
- Include `CONFIRMATION_DESCRIPTION` in tool description
- Transform camelCase params to PascalCase for Outseta API
- Use POST HTTP method

### 3. UPDATE Tools

- Define custom Zod schema with `uid` field and optional update fields
- Include `CONFIRMATION_DESCRIPTION` in tool description
- Extract `uid` from params and use in endpoint URL
- Transform remaining params to PascalCase for Outseta API
- Use PUT HTTP method

## Schema Best Practices

### Field Descriptions

Always include descriptive `.describe()` calls:

```typescript
name: z.string().describe("The name of the resource"),
isActive: z.boolean().describe("Whether the resource is active"),
```

### Optional Fields

Use `.optional()`

```typescript
description: z.string().optional().describe("Optional description");
```

### Default Values

Use `.default()` when you want to provide a default value:

```typescript
name: z.string().default("Default Name").describe("The name of the resource"),
```

### Enums

Use `.enum()` for constrained values:

```typescript
status: z.enum(["Active", "Inactive", "Pending"]).describe("The status of the resource"),
```

### Transformations

Use `.transform()` when API expects different format:

```typescript
billingTerm: z.enum(["Monthly", "Annual"]).transform((val) => {
  switch (val) {
    case "Monthly":
      return 1;
    case "Annual":
      return 2;
    default:
      return undefined;
  }
});
```

## API Transformation Patterns

### Request Transformation (camelCase → PascalCase)

```typescript
const outsetaParams = {
  Name: params.name, // name → Name
  IsActive: params.isActive, // isActive → IsActive
  CreatedDate: params.createdDate, // createdDate → CreatedDate
};
```

### Nested Objects

```typescript
const outsetaParams = {
  Name: params.name,
  PlanFamily: { Uid: params.planFamilyUid }, // Reference by UID
};
```

## Error Handling

The `toolResponse` helper automatically handles errors. Your functions should:

- Throw descriptive Error objects for business logic errors
- Let network errors bubble up (axios will handle them)

## Environment Variables

The API client uses these environment variables:

- `OUTSETA_SUBDOMAIN`: Your Outseta subdomain
- `OUTSETA_API_KEY`: Your API key
- `OUTSETA_API_SECRET`: Your API secret

## Testing Your Tools

1. Build the project: `npm run build`
2. Test with a client that supports MCP protocol
3. Verify tool descriptions appear correctly
4. Test with various parameter combinations
5. Verify error handling works as expected

## Common Gotchas

1. **Field Naming**: Outseta API uses PascalCase, but MCP tools use camelCase
2. **UID References**: When referencing other resources, use `{ Uid: "value" }` format
3. **Pagination**: API uses `offset`/`limit` but tools expose `page`/`perPage`
4. **Filtering**: Operators are prefixed with `__` in API (e.g., `field__gt`)
5. **Confirmation**: Always add confirmation description for destructive operations

## Example: Adding CRM People Tools

Here's a complete example of adding CRM People tools:

```typescript
// src/crm_people/schema.ts
import { z } from "zod";

export const createPersonSchema = z.object({
  firstName: z.string().describe("The first name of the person"),
  lastName: z.string().describe("The last name of the person"),
  email: z.string().email().describe("The email address of the person"),
  accountUid: z
    .string()
    .optional()
    .describe("The UID of the associated account"),
});

// src/crm_people/index.ts
import { z } from "zod";
import outseta, { PaginatedResults, QueryParams } from "../api/index.js";
import { createPersonSchema } from "./schema.js";

export { createPersonSchema };
export type CreatePersonParams = z.infer<typeof createPersonSchema>;

export const getPeople = async (params: QueryParams) => {
  return await outseta.get<PaginatedResults<any>>("/crm/people", { params });
};

export const createPerson = async (params: CreatePersonParams) => {
  const outsetaParams = {
    FirstName: params.firstName,
    LastName: params.lastName,
    Email: params.email,
    ...(params.accountUid && { Account: { Uid: params.accountUid } }),
  };
  return await outseta.post("/crm/people", outsetaParams);
};

// Add to src/tools.ts
import * as crmPeople from "./crm_people/index.js";

server.tool(
  "get_people",
  `Get people from Outseta. ${PAGINATION_DESCRIPTION} ${FILTERING_DESCRIPTION}`,
  queryParamsSchema.shape,
  async (params: QueryParams) => {
    return toolResponse(crmPeople.getPeople, params, "get_people");
  }
);

server.tool(
  "create_person",
  `Create a person in Outseta. ${CONFIRMATION_DESCRIPTION}`,
  crmPeople.createPersonSchema.shape,
  async (params: crmPeople.CreatePersonParams) => {
    return toolResponse(crmPeople.createPerson, params, "create_person");
  }
);
```

This pattern ensures consistency across all tools while maintaining flexibility for domain-specific requirements.
